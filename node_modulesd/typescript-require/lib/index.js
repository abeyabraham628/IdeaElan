"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var vm_1 = require("vm");
var fs_1 = require("fs");
var path_1 = require("path");
var util = __importStar(require("./util"));
// This is an ugly hack, but many typescript things may need reflect-metadata;
// sad fact is that the way this library loads typescript files and the way reflect-metadata
// works are entirely incompatible. This is the simple but hacky workaround
try {
    require('reflect-metadata');
}
catch (e) { }
var tsc = path_1.join(path_1.dirname(require.resolve("typescript")), "tsc.js");
var tscScript = new vm_1.Script(fs_1.readFileSync(tsc, "utf8"), {
    filename: tsc
});
var disallowedOptions = ['outDir', 'outFile', 'rootDir'];
var options = {
    exitOnError: true,
    tmpDir: 'tmp/tsreq',
    extraFiles: [],
    tscOptions: {
        target: "ES5",
        module: "commonjs",
        inlineSourceMap: null
    }
};
function configure(opts) {
    options = util.merge(options, opts);
}
exports.configure = configure;
function register(opts) {
    require.extensions['.ts'] = require.extensions['.tsx'] = function (module) {
        var jsname = compileTS(module);
        runJS(jsname, module);
    };
}
exports.register = register;
var projectBuilt = null;
/**
 * if projectDir is specified return that otherwise return the current working directory.
 **/
function getTsRoot() {
    return (options.projectDir ? options.projectDir : process.cwd());
}
/**
 * Compiles TypeScript file, returns js file path
 * @return {string} js file path
 */
function compileTS(module) {
    var exitCode = 0;
    var tmpDir = path_1.join(getTsRoot(), options.tmpDir);
    var relativeFolder = path_1.dirname(path_1.relative(getTsRoot(), module.filename));
    var jsname = path_1.join(tmpDir, relativeFolder, path_1.basename(module.filename, ".ts") + ".js");
    if (!util.isModified(module.filename, jsname)) {
        return jsname;
    }
    var argv = [
        "node",
        "tsc.js",
        "--outDir",
        tmpDir,
        "--rootDir",
        process.cwd()
    ];
    if (options.projectDir && projectBuilt === null) {
        // For more complex projects it's better to set up a tsconfig.json file with the outDir set to
        // the tmpDir and let it compile them all when we first start up; in that case
        argv = [
            "node",
            "tsc.js",
            "-p",
            options.projectDir
        ];
        projectBuilt = false;
    }
    else {
        Object.keys(options.tscOptions).forEach(function (k) {
            if (options.tscOptions[k] === false || disallowedOptions.indexOf(k) > -1) {
                // Ignore disallowed options; also, tsc doesn't ever require a "false" option, it just
                // defaults to no for those unless specified otherwise, so ignore those too.
                // When it's just a "true" then we don't need a value.
                return;
            }
            argv.push("--" + k);
            if (options.tscOptions[k] && options.tscOptions[k] !== true) {
                argv.push(options.tscOptions[k]);
            }
        });
        argv = argv.concat(options.extraFiles);
        argv.push(module.filename);
    }
    if (!projectBuilt) {
        console.log(argv);
        var proc = util.merge(util.merge({}, process), {
            argv: util.compact(argv),
            exit: function (code) {
                if (code !== 0 && options.exitOnError) {
                    console.error('Fatal Error. Unable to compile TypeScript file. Exiting.');
                    process.exit(code);
                }
                exitCode = code;
            }
        });
        var sandbox = {
            process: proc,
            require: require,
            module: module,
            Buffer: Buffer,
            setTimeout: setTimeout,
            __filename: tsc,
            __dirname: path_1.dirname(tsc)
        };
        tscScript.runInNewContext(sandbox, {
            filename: tsc
        });
        if (exitCode !== 0) {
            throw new Error('Unable to compile TypeScript file.');
        }
        if (projectBuilt === false) {
            // We're building the full project and only need to do it once
            projectBuilt = true;
        }
    }
    return jsname;
}
function runJS(jsname, module) {
    var content = fs_1.readFileSync(jsname, 'utf8');
    var sandbox = {};
    for (var k in global) {
        sandbox[k] = global[k];
    }
    sandbox.require = module.require.bind(module);
    sandbox.require.cache = require.cache;
    sandbox.require.resolve = require.resolve.bind(sandbox.require);
    sandbox.exports = module.exports;
    sandbox.__filename = jsname;
    sandbox.__dirname = path_1.dirname(module.filename);
    sandbox.module = module;
    sandbox.global = sandbox;
    sandbox._global = global;
    sandbox.Reflect = global.Reflect;
    return vm_1.runInNewContext(content, sandbox, { filename: jsname });
}
